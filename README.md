

**用终端的时候，可以单独对一个文件，比如对`helloworld.c`文件进行编辑，要先找桌子，再从桌子上找文件夹，再从文件夹翻子文件夹，再从子文件夹找出纸来写东西，在电脑怎么实现呢？**  

```
Macbook:~ ccf$ cd Desktop
Macbook:Desktop ccf$ cd C
Macbook:C ccf$ cd testc
Macbook:testc ccf$ vi a.c
```

**对于其他文件的链接，比如想在`helloworld.c`文件里使用math函数库的一个`pow`函数，怎么用？首先要找到这个文件，其次查找里面的pow函数，在电脑又如何实现呢？一开始我想的很简单直接，`#include<math>`不就行了？其实，编译器自身还做了很多的步骤**  

先创个helloworld.c文件

![截屏2021-10-29 11 55 18](https://user-images.githubusercontent.com/74129445/139373109-dd0d83f8-1141-437c-8d5c-a6d5dfdb092e.png)  


1、**预编译**，命令为`gcc -E helloworld.c`  

C语言代码在交给编译器之前，会先由预处理器进行一些文本替换方面的操作，例如宏展开、文件包含、删除部分代码等。  

在正常的情况下，GCC 不会保留预处理阶段的输出文件，也即.i文件。然而，可以利用-E选项保留预处理器的输出文件，以用于诊断代码。-E选项指示 GCC 在预处理完毕之后即可停止。  

默认情况下，预处理器的输出会被导入到标准输出流（也就是显示器），可以利用-o选项把它导入到某个输出文件  

因为头文件可能相当大，如果源文件包括了多个头文件，那么它的预处理器输出可能会庞杂难读。使用-C选项会很有帮助，这个选项可以阻止预处理器删除源文件和头文件中的注释 

所以可以输入命令`gcc -E -C helloworld.c -o helloworld.i`来查看  

即：  
输入命令：  

![截屏2021-10-29 11 47 40](https://user-images.githubusercontent.com/74129445/139372503-3bdebba6-c1c7-4fca-95ce-4368efaa4429.png)  

.i文件：  
![截屏2021-10-29 12 48 10](https://user-images.githubusercontent.com/74129445/139377688-aa3270f4-c6e0-494e-9f0d-da982d79aac9.png)  


2、**编译**，命令为`gcc -S helloworld.i`


通过给 gcc 指令添加 -S（注意是大写）选项，即可令 GCC 编译器仅将指定文件加工至编译阶段，并生成对应的汇编代码文件  

经过执行 `gcc -S` 指令，其生成了一个名为 `helloworld.s` 的文件，这就是经过编译的汇编代码文件。  

当然如果需要的话，我们还可以为 `gcc -S` 指令添加 `-o` 选项，令 GCC 编译器将编译结果保存在我们指定的文件中  

需要注意的是，`gcc -S` 指令操作的文件并非必须是经过预处理后得到的 .i 文件，-S 选项的功能是令 GCC 编译器将指定文件处理至编译阶段结束。这也就意味着，**`gcc -S` 指令可以操作预处理后的 .i 文件，也可以操作源代码文件.c**  

即：  

* 如果操作对象为 .i 文件，则 GCC 编译器只需编译此文件；
* 如果操作对象为 .c 或者 .cpp 源代码文件，则 GCC 编译器会对其进行预处理和编译这 2 步操作。

所以，可以使用`gcc -S helloworld.i -o helloworld.s`或者`gcc -S helloworld.c -o helloworld.s`来查看  

输入命令：  
![截屏2021-10-29 11 54 18](https://user-images.githubusercontent.com/74129445/139373008-2841a008-a88d-4501-a002-e002926d48fb.png)  

.s文件（完蛋）：  

![截屏2021-10-29 11 55 05](https://user-images.githubusercontent.com/74129445/139373087-99bfe2cc-64b3-49f7-9f76-5b04dfea74ec.png)  
我把两个库又加上了：  

![截屏2021-10-29 12 53 40](https://user-images.githubusercontent.com/74129445/139377947-1325e894-d1ba-45bd-8d38-78bf8d70ff4c.png)  
然后重新运行  
![截屏2021-10-29 12 54 34](https://user-images.githubusercontent.com/74129445/139378014-82066849-3f8c-4ec0-a8d6-51bd2d4f0674.png)  
.s文件：  
![截屏2021-10-29 12 55 28](https://user-images.githubusercontent.com/74129445/139378106-5d064d24-b2f4-440c-8ba8-842fd2d1eb25.png)  

看来创建汇编必须要有所有的库  

3、**汇编**，命令为`gcc -c helloworld.s`  

简单地理解，汇编其实就是将汇编代码转换成可以执行的机器指令。大部分汇编语句对应一条机器指令，有的汇编语句对应多条机器指令。相对于编译操作，汇编过程会简单很多，它并没有复杂的语法，也没有语义，也不需要做指令优化，只需要根据汇编语句和机器指令的对照表一一翻译即可。  

该指令生成了和 `helloworld.s` 同名但后缀名为 .o 的文件，这就是经过汇编操作得到的目标文件。  

当然如果必要的话，还可以为 gcc -c 指令在添加一个 -o 选项，用于将汇编操作的结果输入到指定文件中  

即`gcc -c helloworld.s -o helloworld.o`  

默认情况下汇编操作会自动生成一个和汇编代码文件名称相同、后缀名为 .o 的二进制文件（又称为**目标文件**）。  

即：  

输入命令：  

![截屏2021-10-29 12 58 10](https://user-images.githubusercontent.com/74129445/139378336-9ae9d34c-1ceb-4f78-8439-4e8ca264c11d.png)  

.o文件（这里我用的仍然是没有库的最开始的代码）：  

`......打不开 ` 

这就尴尬了，根本看不到，还好我又找到了新的命令来查看.o 文件：`objdump -h` obj:输出目标文件的所有段概括（）

输入命令：  
![截屏2021-10-29 13 05 56](https://user-images.githubusercontent.com/74129445/139378924-fbc0c8fd-4871-4eb4-91a5-daaf506f8fbd.png)  
输出.o文件：

![截屏2021-10-29 13 06 34](https://user-images.githubusercontent.com/74129445/139378965-3bee57b4-8fb6-423b-a0e5-9cb26ce8a7f8.png)  

4、**链接** 命令为`gcc helloworld.o`

**目标文件**已经是二进制文件，与可执行文件的组织形式类似，只是有些函数和全局变量的地址还未找到，因此还无法执行。**链接的作用**就是找到这些目标地址，将所有的目标文件组织成一个可以执行的二进制文件。  

完成链接操作，并不需要给 g++ 添加任何选项，只要将汇编阶段得到的 `helloworld.o` 作为参数传递给它，g++就会在其基础上完成链接操作

链接器必须将程序中所用到的所有C标准库函数加入其中。对于链接器而言，链接库不过是一个具有许多**目标文件**x的集合，它们在一个文件中以方便处理。链接器把多个二进制的**目标文件**（object file）链接成一个单独的可执行文件。在链接过程中，它必须**把符号**（变量名、函数名等一些列标识符）**用对应的数据的内存地址**（变量地址、函数地址等）**替代**，以完成程序中多个模块的外部引用。  

标准库的大部分函数通常放在**文件** `libc.a` 中（文件名后缀.a代表“achieve”，译为“获取”），或者放在用于**共享的动态链接文件** `libc.so` 中（文件名后缀.so代表“share object”，译为“共享对象”）。这些链接库一般位于 `/lib/` 或 `/usr/lib/`，或者位于 GCC 默认搜索的其他目录。  

当使用 GCC 编译和链接程序时，GCC 默认会链接 `libc.a` 或者 `libc.so`，但是对于其他的库（例如非标准库、第三方库等），就需要手动添加。  

通常，GCC 会自动在标准库目录中搜索文件，例如 `/usr/lib`，这种情况下把链接库作为一般的目标文件，为 GCC 指定该链接库的完整路径与文件名。  

如果想链接其它目录中的库，就得特别指明。  

如，如果链接库名为 `libm.a`，并且位于 `/usr/lib` 目录，那么下面的命令会让 GCC 编译 `helloworld.c`，然后将 `libm.a` 链接到 `helloworld.o`：  

```
gcc helloworld.c -o helloworld.out /usr/lib/libm.a

```

如果链接为非 `libc.a` 或者 `libc.so` 库，就要使用-L选项，为 GCC 增加另一个搜索链接库的目录  

```
gcc helloworld.c -o helloworld.out -L/usr/lib -lm

//使用-L选项，可以为 GCC 增加另一个搜索链接库的目录

//m是基本名称，GCC 会在-l选项后紧跟着的基本名称的基础上自动添加这些前缀、后缀，本例中，基本名称为 m,当然m也可以换成其他
```

当然，还有一种通用的方法，即

```
把包括所需链接库的目录加到环境变量 LIBRARYPATH 中。

```

现在对我的helloworld.o文件继续探索：

输入命令：  

![截屏2021-10-29 13 18 30](https://user-images.githubusercontent.com/74129445/139379948-2608d62f-df99-4069-9f46-c5671f97a91e.png)  

结果：

![截屏2021-10-29 13 20 04](https://user-images.githubusercontent.com/74129445/139380058-a44aa285-ff80-491d-815d-ff6fc7b6d66d.png)  

成功生成a.out文件  

但运行a.out文件时,并没有输出，这是因为没有链接两个库，现在对两个库进行手动链接  






















